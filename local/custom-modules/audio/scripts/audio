#!/usr/bin/python
# Author tuxudo

import subprocess
import os
import plistlib
import sys

sys.path.insert(0, '/usr/local/munki')

from munkilib import FoundationPlist

def get_audio_info():
    '''Uses system profiler to get Audio info for this machine.'''
    cmd = ['/usr/sbin/system_profiler', 'SPAudioDataType', '-xml']
    proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (output, unused_error) = proc.communicate()

    try:
        plist = plistlib.readPlistFromString(output)
        # system_profiler xml is an array
        sp_dict = plist[0]
        items = sp_dict['_items']
        return items
    except Exception:
        return {}

def flatten_audio_info(array, localization):
    '''Un-nest Audio devices, return array with objects with relevant keys'''
    out = []
    for obj in array:
        # Return nothing if machine doesn't have Audio
        if 'Audio' in obj and obj['Audio'] == "no_hardware":
            return {}

        device = {}
        for item in obj:
            # Don't process the bus itself
            if item == '_name' and "audio_bus" in obj[item]:
                continue  
            elif item == '_items':
                out = out + flatten_audio_info(obj['_items'], localization)
                
            elif item == '_name':
                device['name'] = obj[item]
            elif item == 'coreaudio_default_audio_output_device':
                device['default_audio_output'] = obj[item]
            elif item == 'coreaudio_default_audio_input_device':
                    device['default_audio_input'] = obj[item]
            elif item == 'coreaudio_device_input':
                device['device_input'] = obj[item]
            elif item == 'coreaudio_device_output':
                device['device_output'] = obj[item]
            elif item == 'coreaudio_device_manufacturer':
                device['device_manufacturer'] = obj[item]
            elif item == 'coreaudio_device_srate':
                device['device_srate'] = obj[item]
            elif item == 'coreaudio_device_transport':
                device['device_transport'] = obj[item]
            elif item == 'coreaudio_input_source':
                device['input_source'] = obj[item]
            elif item == 'coreaudio_output_source':
                device['output_source'] = obj[item]

        # Only append device if it has a name
        if 'name' in device:
            out.append(device)
            
    return out

def to_bool(s):
    if s == True:
        return 1
    else:
        return 0 

def main():
    """Main"""
    # Create cache dir if it does not exist
    cachedir = '%s/cache' % os.path.dirname(os.path.realpath(__file__))
    if not os.path.exists(cachedir):
        os.makedirs(cachedir)

    # Skip manual check
    if len(sys.argv) > 1:
        if sys.argv[1] == 'manualcheck':
            print 'Manual check: skipping'
            exit(0)

    # Set the encoding
    reload(sys)
    sys.setdefaultencoding('utf8')

    # Read in English localizations from SystemProfiler
    if os.path.isfile('/System/Library/SystemProfiler/SPAudioReporter.spreporter/Contents/Resources/en.lproj/Localizable.strings'):
        localization = FoundationPlist.readPlist('/System/Library/SystemProfiler/SPAudioReporter.spreporter/Contents/Resources/en.lproj/Localizable.strings')
    elif os.path.isfile('/System/Library/SystemProfiler/SPAudioReporter.spreporter/Contents/Resources/English.lproj/Localizable.strings'):
        localization = FoundationPlist.readPlist('/System/Library/SystemProfiler/SPAudioReporter.spreporter/Contents/Resources/English.lproj/Localizable.strings')
    else:
        localization = {}

    # Get results
    result = dict()
    info = get_audio_info()
    result = flatten_audio_info(info, localization)

    # Write audio results to cache
    output_plist = os.path.join(cachedir, 'audio.plist')
    plistlib.writePlist(result, output_plist)
#    print plistlib.writePlistToString(result)

if __name__ == "__main__":
    main()
